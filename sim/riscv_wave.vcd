$date
	Sat Feb 14 00:17:20 2026
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module riscv_tb $end
$var wire 32 ! test_result [31:0] $end
$var reg 1 " clk $end
$var reg 1 # rst_n $end
$scope module dut $end
$var wire 1 " clk $end
$var wire 1 # rst_n $end
$var wire 32 $ test_result [31:0] $end
$var wire 1 % zero $end
$var wire 32 & write_data [31:0] $end
$var wire 2 ' result_src [1:0] $end
$var wire 1 ( reg_write $end
$var wire 32 ) read_data [31:0] $end
$var wire 1 * pc_src $end
$var wire 32 + pc [31:0] $end
$var wire 1 , mem_write $end
$var wire 32 - instr [31:0] $end
$var wire 1 . funct7b5 $end
$var wire 1 / alu_src $end
$var wire 32 0 alu_result [31:0] $end
$var wire 3 1 alu_control [2:0] $end
$scope module cu $end
$var wire 3 2 funct3 [2:0] $end
$var wire 1 . funct7b5 $end
$var wire 7 3 op [6:0] $end
$var wire 1 * pc_src $end
$var wire 1 % zero $end
$var reg 3 4 alu_control [2:0] $end
$var reg 2 5 alu_op [1:0] $end
$var reg 1 / alu_src $end
$var reg 1 6 branch $end
$var reg 1 7 jump $end
$var reg 1 , mem_write $end
$var reg 1 ( reg_write $end
$var reg 2 8 result_src [1:0] $end
$upscope $end
$scope module dp $end
$var wire 3 9 alu_control [2:0] $end
$var wire 1 / alu_src $end
$var wire 1 " clk $end
$var wire 1 * pc_src $end
$var wire 1 ( reg_write $end
$var wire 2 : result_src [1:0] $end
$var wire 1 # rst_n $end
$var wire 1 % zero $end
$var wire 32 ; write_data [31:0] $end
$var wire 32 < src_b [31:0] $end
$var wire 32 = src_a [31:0] $end
$var wire 32 > read_data [31:0] $end
$var wire 32 ? pc_target [31:0] $end
$var wire 32 @ pc_plus4 [31:0] $end
$var wire 32 A pc_out [31:0] $end
$var wire 32 B pc_next [31:0] $end
$var wire 32 C instr [31:0] $end
$var wire 32 D imm_ext [31:0] $end
$var wire 32 E alu_result [31:0] $end
$var reg 32 F result [31:0] $end
$scope module my_alu $end
$var wire 3 G alu_control [2:0] $end
$var wire 32 H b [31:0] $end
$var wire 1 % zero $end
$var wire 32 I a [31:0] $end
$var reg 32 J result [31:0] $end
$upscope $end
$scope module my_immgen $end
$var wire 32 K inst [31:0] $end
$var reg 32 L imm [31:0] $end
$upscope $end
$scope module my_pc $end
$var wire 1 " clk $end
$var wire 32 M pc_next [31:0] $end
$var wire 1 # rst_n $end
$var reg 32 N pc_out [31:0] $end
$upscope $end
$scope module my_rf $end
$var wire 5 O a1 [4:0] $end
$var wire 5 P a2 [4:0] $end
$var wire 5 Q a3 [4:0] $end
$var wire 1 " clk $end
$var wire 1 # rst_n $end
$var wire 32 R wd3 [31:0] $end
$var wire 1 ( we3 $end
$var wire 32 S rd2 [31:0] $end
$var wire 32 T rd1 [31:0] $end
$upscope $end
$upscope $end
$scope module my_dmem $end
$var wire 32 U addr [31:0] $end
$var wire 1 " clk $end
$var wire 32 V rdata [31:0] $end
$var wire 32 W wdata [31:0] $end
$var wire 1 , we $end
$upscope $end
$scope module my_imem $end
$var wire 32 X addr [31:0] $end
$var wire 32 Y data [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b101000000000000010010011 Y
b0 X
bx W
bx V
b1010 U
b0 T
bx S
b1010 R
b1 Q
b1010 P
b0 O
b0 N
b100 M
b1010 L
b101000000000000010010011 K
b1010 J
b0 I
b1010 H
b0 G
b1010 F
b1010 E
b1010 D
b101000000000000010010011 C
b100 B
b0 A
b100 @
b1010 ?
bx >
b0 =
b1010 <
bx ;
b0 :
b0 9
b0 8
07
06
b10 5
b0 4
b10011 3
b0 2
b0 1
b1010 0
1/
0.
b101000000000000010010011 -
0,
b0 +
0*
bx )
1(
b0 '
bx &
0%
b1010 $
0#
0"
b1010 !
$end
#5000
1"
#10000
0"
1#
#15000
b10100 F
b10100 R
b10100 !
b10100 $
b10100 0
b10100 E
b10100 J
b10100 U
b10100 <
b10100 H
b10 Q
b10100 P
b10100 D
b10100 L
b1010000000000000100010011 -
b1010000000000000100010011 C
b1010000000000000100010011 K
b1010000000000000100010011 Y
b1000 B
b1000 M
b11000 ?
b1000 @
b100 +
b100 A
b100 N
b100 X
1"
#20000
0"
#25000
b11110 F
b11110 R
b11110 !
b11110 $
b11110 0
b11110 E
b11110 J
b11110 U
b10100 &
b10100 ;
b10100 S
b10100 W
b1010 =
b1010 I
b1010 T
b10 5
1(
0/
b10100 <
b10100 H
b11 Q
b10 P
b1 O
b110011 3
b0 D
b0 L
b1000001000000110110011 -
b1000001000000110110011 C
b1000001000000110110011 K
b1000001000000110110011 Y
b1100 B
b1100 M
b1000 ?
b1100 @
b1000 +
b1000 A
b1000 N
b1000 X
1"
#30000
0"
#35000
b100 F
b100 R
b100 !
b100 $
b100 0
b100 E
b100 J
b100 U
b100 <
b100 H
b11110 &
b11110 ;
b11110 S
b11110 W
b0 =
b0 I
b0 T
1/
1,
b0 5
0(
b100 Q
b11 P
b0 O
b10 2
b100011 3
b100 D
b100 L
b1100000010001000100011 -
b1100000010001000100011 C
b1100000010001000100011 K
b1100000010001000100011 Y
b10000 B
b10000 M
b10000 ?
b10000 @
b1100 +
b1100 A
b1100 N
b1100 X
1"
#40000
0"
#45000
b11110 F
b11110 R
bx &
bx ;
bx S
bx W
b1 '
b1 8
b1 :
1(
1/
0,
b100 P
b11 3
b10000000010001000000011 -
b10000000010001000000011 C
b10000000010001000000011 K
b10000000010001000000011 Y
b10100 B
b10100 M
b10100 ?
b10100 @
b10000 +
b10000 A
b10000 N
b10000 X
b11110 )
b11110 >
b11110 V
1"
#50000
0"
#55000
bx )
bx >
bx V
bx F
bx R
x%
bx !
bx $
bx 0
bx E
bx J
bx U
bx =
bx I
bx T
0(
0/
b0 '
b0 8
b0 :
bx <
bx H
bx Q
bx P
bx O
bx 2
bx 3
x.
b0 D
b0 L
bx -
bx C
bx K
bx Y
b11000 B
b11000 M
bx &
bx ;
bx S
bx W
b10100 ?
b11000 @
b10100 +
b10100 A
b10100 N
b10100 X
1"
#60000
0"
#65000
b11100 B
b11100 M
b11000 ?
b11100 @
b11000 +
b11000 A
b11000 N
b11000 X
1"
#70000
0"
#75000
b100000 B
b100000 M
b11100 ?
b100000 @
b11100 +
b11100 A
b11100 N
b11100 X
1"
#80000
0"
#85000
b100100 B
b100100 M
b100000 ?
b100100 @
b100000 +
b100000 A
b100000 N
b100000 X
1"
#90000
0"
#95000
b101000 B
b101000 M
b100100 ?
b101000 @
b100100 +
b100100 A
b100100 N
b100100 X
1"
#100000
0"
#105000
b101100 B
b101100 M
b101000 ?
b101100 @
b101000 +
b101000 A
b101000 N
b101000 X
1"
#110000
0"
